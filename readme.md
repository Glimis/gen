使用代码生成器,是初始化代码的一种较为灵活的方式

本项目用于分享内部的gen脚手架


## 简介
在一个快速搭建的管理平台中 【从0到1,性能与功能往后调】

前端业务开发搭配为`UI库 + MVVM框架 + 相关的Model层组件`,对应了`MVVM`三部分

后端业务开发搭配基本为`router + orm`,对应的是`MVC`【router产生V】

以前端`element + vue + vuex`,后端`koa + sequelize`

此时

后端模块新增包括
  1.添加/注册 orm模型
  2.添加/注册 业务路由

前端模块新增包括
  1.添加/注册 store
  2.注册 router
  3.添加 view

这五部,在重框架中可以做到统一,但灵活度有限[获取复杂度略高],此项目用来描述如何使用`模板/ast`,通过描述模型,快速生成上述五部分

## demo
此处用`babel + ejs`实现了上述功能【用来试水】

配合`command`,可以明显提高速度 --> 定义完数据模型后,即可生成一个还能用的页面 【针对Bi,使用装饰配合试图或者存储过程】

但每个部分都有不同的痛点

### 注册型
  如前后端路由,纯js,逻辑不复杂,但不能使用模板【当前页面需要动态添加】
  在demo中直接使用ast
  在registerGenerator中,配合注释模板 -> 注释+ast 【省略了位置的查找】

  本身语言为js/ts,ast直接使用babel系列

### 新增型
  如视图
  模板肯定是最好的选择,所有模板系列【asp/jsp】的技巧都可以用上,尤其是include【模拟组件,正则替换即可,ejs更香】
  而且比ast有更宽泛的适用性 【比如vue,需要三类ast】

  问题是
  
  ejs文件会很多 --> 定个初始化标准即可,不难
  html/vue格式化 --> 交给vscode

## 数据收集
目前使用`sequelize`配合装饰进行收集,在运行gen时,生成全局参数,使装饰有效【在运行期无效】

另一种方式是讲sequelize提取到新的文件夹,而后生成赶紧的模型


### 装饰器 View 与 ViewDependent
form与table地狱

### Layout
默认模型直接生成试图,包括查询列表与详情,编辑form
可通过Layout进行View的修改

### form
View代表在编辑form时,比较关键的属性
- type,类型与组件
  
  可以进行推断,比如时间,数字,文本,布尔,甚至关联关系也可以推断出select
  注:
  针对数据库将外键逻辑放到代码而非数据库等优化方式,需要重写sequelize
- label
   
  也可以放到备注里
- index
  
  顺序
- tpl
  
  引用模板,模板代表layout/include
  默认按顺序显示
- 验证
  
  根据类型推断,可以进行验证,验证可以用sequelize提供的数据库兜底方案,也可以自定义【参考前端验证规则】,将验证规则通过tpl注册到前端,而后端,写入router或model本地的bus中,通过throw 进行拦截验证 【为了用于拓展前端难以校验的验证,如唯一性,关联性,也可以分开,在后台路由中,一个前端验证,与前端代码一致,一个后端验证,用于拓展】


### table
ViewDependent为关联模型的参数
- fields
  在一对多时展示为table,
  一对一时,不展示 【form or 冗余】

地狱模式是form与table联合的展示
意思下就行,这个初始化模板,不是重型框架

### 前端模型与后端路由【vuex】
需要根据router重新生成vuex 【后台router初始化】
此处需要对vuex进行拆分,通常最简单的方式是根据后端router【api】,生成前端api文件
而后由前端自定义vuex进行管理
在前端node注入后,vuex中的action部分,可直接对应一个api  --> 自动生成【关联逻辑交给后台router】
故,将vuex分解成两部
- 初始化阶段
  
  使用模板进行初始化
- 运行阶段 【router修改后,更改】
  
  使用ast追加 或 action 重写 【需要提取出来】
  